<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Shamir's Secret Sharing Algorithm</title>

  <link rel="stylesheet" href="./bootstrap.css"/>
  <script src="./vue.js"></script>
  <script src="./qrcode.js"></script>
  <script src="./basex.js"></script>
  <script src="./shamir.js"></script>
  <script src="./crypto.js"></script>
  <script src="./jsqr.js"></script>

</head>
<body>

<div id="app" class="p-4 mb-5">
  <div class="row">
    <div class="col">
      <h2 class="mb-4">Shamir's Secret Sharing Algorithm</h2>

      <div class="card">
        <div class="card-header">
          <ul class="nav nav-tabs card-header-tabs">
            <li class="nav-item" v-for="page in pages">
              <a class="nav-link" :class="{ active: page.id === currentPage }" href="#"
                 @click.prevent="currentPage = page.id">{{ page.title }}</a>
            </li>
          </ul>
        </div>
        <div class="card-body">
          <div v-show="currentPage === 'split'">
            <page-split/>
          </div>
          <div v-show="currentPage === 'recover'">
            <page-recover :params="pageParams"/>
          </div>
          <div v-show="currentPage === 'about'">
            <page-about/>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">

  (async () => {
    const baseEncoding = BaseX.create('1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM');

    // const readStorage = (key, defaultValue) => {
    //   try {
    //     return JSON.parse(sessionStorage.getItem(key)) ?? defaultValue;
    //   }catch {
    //     return defaultValue;
    //   }
    // }

    const baseUrl = (path) => {
      const url = new URL(top.location.href);
      url.hash = path;

      return url.toString();
    };

    const app = Vue.createApp({
      data: () => ({
        pageParams: [],
        currentPage: 'split',
        pages: [
          {
            id: 'split',
            title: 'Split',
          }, {
            id: 'recover',
            title: 'Recover',
          }, {
            id: 'about',
            title: 'About',
          },
        ],
      }),
      mounted() {
        const url = new URL(top.location.href);
        if (url.hash) {
          const [page, ...params] = url.hash.slice(1).split('/').filter((item) => item);

          this.currentPage = page;
          this.pageParams = params;
        }
      },
    });

    app.component('page-split', {
      template: `
        <p class="card-text">
        This app allows you to split your secret data into multiple <strong>shares</strong> with AES-256 encryption
        algorithm.<br/>
        The number of randomly picked shares (defined as <strong>quorum</strong>) will be required to be provided to
        recover your secret data.<br/>
        <br/>

        <strong>Note: it is mathematically impossible to recover your secret without minimum amount of shares!</strong>
        </p>

        <div class="row">
        <div class="col-6">
          <div class="mb-3">
            <label for="shares">Number of shares</label>
            <input type="number" id="shares" :min="numQuorum" v-model="numOfShares" class="form-control font-awesome"/>
          </div>
        </div>
        <div class="col-6">
          <div class="mb-3">
            <label for="quorum">Quorum</label>
            <input type="number" id="quorum" v-model="numQuorum" class="form-control font-awesome" :max="numOfShares"/>
          </div>
        </div>
        </div>

        <div class="mb-3">
        <label for="data">Secret data</label>
        <textarea id="data" v-model="data" class="form-control font-awesome" rows="5"></textarea>
        </div>

        <div class="mb-3">
        <label>
          <input type="checkbox" v-model="generateQRCodes"/>
          Generate QR codes
        </label>
        </div>

        <div class="mb-3" v-if="generateQRCodes">
        <label>
          <input type="checkbox" v-model="embedLinksIntoQRCodes"/>
          Embed recover URL into QR codes
        </label>
        </div>

        <div v-if="data">
        <hr class="my-3"/>

        <h5>Result</h5>
        <div class="row">
          <div class="col-12 col-xs-6 col-md-3 text-center mb-3" v-for="share in shares">
            <div v-if="generateQRCodes">
              <qrcode v-if="embedLinksIntoQRCodes" :data="recoverUrl(share)"></qrcode>
              <qrcode v-else :data="share"></qrcode>
            </div>
            <textarea wrap="soft" readonly class="form-control font-awesome" rows="5">{{ share }}</textarea>
          </div>
        </div>
        </div>
      `,
      data: () => ({
        data: '',
        numOfShares: 3,
        numQuorum: 2,
        shares: null,
        generateQRCodes: false,
        embedLinksIntoQRCodes: false,
      }),
      methods: {
        recoverUrl: (hex) => baseUrl(`/recover/${ hex }`),
        async splitSecret() {
          const encoded = new TextEncoder().encode(this.data);
          const encrypted = await encrypt(encoded);
          const shares = Shamir.split(encrypted, this.numOfShares, this.numQuorum, randomBytes);

          this.shares = shares.map((share) => baseEncoding.encode(share));
        },
      },
      watch: {
        data() {
          this.splitSecret();
        },
        numOfShares() {
          this.splitSecret();
        },
        numQuorum() {
          this.splitSecret();
        },
      },
    });

    app.component('page-recover', {
      props: ['params'],
      template: `
        <div class="mb-3" v-for="num in numOfShares">
        <div class="row">
          <div class="col-sm-8 col-12">
            <label :for="\`share-\${num}\`">Share #{{ num }}</label>
            <div class="input-group">
              <input type="text" :id="\`share-\${num}\`" v-model="shares[num - 1]" class="form-control font-awesome"
                     :disabled="success && num === numOfShares"/>
              <button class="btn btn-outline-secondary" v-if="shares[num - 1]" @click="deleteItem(num - 1)">
                â¤«
              </button>
            </div>
          </div>

          <template v-if="shares[num - 1]">
            <div class="col-sm-2 col-6">
              <label>&nbsp</label>
              <div class="input-group">
                <div class="input-group-text">ID:</div>
                <input type="text" class="form-control font-awesome" readonly :value="extractID(shares[num - 1])"
                       :class="{ 'is-invalid' : extractID(shares[num - 1]) !== extractID(shares[0]) }">
              </div>
            </div>
            <div class="col-sm-2 col-6">
              <label>&nbsp</label>
              <div class="input-group">
                <div class="input-group-text">SEQ:</div>
                <input type="text" class="form-control font-awesome" readonly :value="extractSeq(shares[num - 1])">
              </div>
            </div>
          </template>
          <template v-else>
            <div class="col-sm-4" v-if="!success">
              <label>&nbsp</label>
              <div class="text-end text-sm-start">
                <button class="btn btn-secondary" :disabled="success" @click="scanQRCode()">
                  <template v-if="!scanningQRCode">Scan QR Code</template>
                  <template v-else>Cancel</template>
                </button>
              </div>
              <div class="py-3" v-if="scanningQRCode">
                <qrcode-scanner @code="processQRCodeData($event)"/>
              </div>
            </div>
          </template>
        </div>
        </div>

        <div v-if="shares.length">
          <h5>Secret data</h5>
          <div class="mb-3">
            <textarea v-model="result" readonly class="form-control font-awesome" rows="10" :class="{ 'border-success':success, 'border-danger':!success }"></textarea>
          </div>
        </div>


      `,
      data: () => ({
        success: false,
        result: '',
        shares: [],
        scanningQRCode: false,
      }),
      methods: {
        processQRCodeData(data) {
          const urlMatch = data.match(/#\/recover\/([^/]+)/);

          if (urlMatch) {
            this.shares.push(urlMatch[1]);
          } else {
            this.shares.push(data);
          }

          this.scanningQRCode = false;
        },
        scanQRCode() {
          this.scanningQRCode = !this.scanningQRCode;
        },
        deleteItem(index) {
          this.shares.splice(index, 1);
        },
        extractID(tok) {
          return uint8ArrayToHex(baseEncoding.decode(tok).slice(1, 5));
        },
        extractSeq(tok) {
          return uint8ArrayToHex(baseEncoding.decode(tok).slice(0, 1));
        },
        async recover() {
          try {
            const shares = this.shares.filter((item) => !!item).map((shareHex) => baseEncoding.decode(shareHex));
            const recovered = Shamir.recover(shares);
            const decrypted = await decrypt(recovered);

            this.result = new TextDecoder().decode(decrypted);
            this.success = true;
          } catch (e) {
            this.result = `Error decoding: ${ e.message }`;
            this.success = false;
          }
        },
      },
      computed: {
        numOfShares() {
          return this.sharesLength + (this.success ? 0 : 1);
        },
        sharesLength() {
          return this.shares?.length ?? 0;
        }
      },
      watch: {
        shares: {
          deep: true,
          immediate: true,
          handler() {
            for (let i = this.sharesLength - 1; i >= 0; i--) {
              if (this.shares[i]) {
                break;
              }

              this.shares.splice(i, 1);
            }

            this.recover();
            // sessionStorage.setItem('shares', JSON.stringify(this.shares));
          },
        },
        params(params) {
          if (params) {
            params.forEach((param) => {
              if (this.shares.some((item) => item === param)) {
                return;
              }

              this.shares[this.shares.length] = param;
            });
          }
        },
      },
    });

    app.component('page-about', {
      template: `
        <h5>About</h5>
      `,
      data: () => ({}),
    });

    app.component('qrcode', {
      template: `<img v-if="src" :src="src" class="qrcode"/>`,
      props: ['data'],
      data: () => ({
        src: '',
      }),
      watch: {
        data: {
          immediate: true,
          handler() {
            QRCode.toDataURL(this.data, {
              errorCorrectionLevel: 'H',
            }).then((url) => this.src = url);
          },
        },
      },
    });

    app.component('qrcode-scanner', {
      template: `
        <div class="ratio ratio-4x3">
          <video :id="videoId" style="width: 0; height: 0"></video>
          <canvas :id="canvasId"></canvas>
        </div>`,
      data: () => ({
        canvasId: `qrcode-scanner-canvas-${ uint8ArrayToHex(randomBytes(4)) }`,
        videoId: `qrcode-scanner-video-${ uint8ArrayToHex(randomBytes(4)) }`,
        active: true,
        stop: () => void 0,
      }),
      unmounted() {
        console.log('unmounted');
        this.active = false;
        this.stop();
      },
      mounted() {
        const video = document.getElementById(this.videoId);
        const canvasElement = document.getElementById(this.canvasId);
        const canvas = canvasElement.getContext('2d');

        function drawLine(begin, end, color) {
          canvas.beginPath();
          canvas.moveTo(begin.x, begin.y);
          canvas.lineTo(end.x, end.y);
          canvas.lineWidth = 4;
          canvas.strokeStyle = color;
          canvas.stroke();
        }

        const tick = () => {
          if (!this.active) {
            return;
          }

          if (video.readyState === video.HAVE_ENOUGH_DATA) {
            canvasElement.height = video.videoHeight;
            canvasElement.width = video.videoWidth;
            canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
            const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
            const code = jsQR(imageData.data, imageData.width, imageData.height, {
              inversionAttempts: 'dontInvert',
            });

            if (code && code.data) {
              drawLine(code.location.topLeftCorner, code.location.topRightCorner, '#ff3b58');
              drawLine(code.location.topRightCorner, code.location.bottomRightCorner, '#ff3b58');
              drawLine(code.location.bottomRightCorner, code.location.bottomLeftCorner, '#ff3b58');
              drawLine(code.location.bottomLeftCorner, code.location.topLeftCorner, '#ff3b58');

              setTimeout(() => {
                this.$emit('code', code.data);
              }, 500);

              return;
            }
          }

          requestAnimationFrame(tick);
        };

        // Use facingMode: environment to attemt to get the front camera on phones
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }).then((stream) => {
          video.srcObject = stream;
          video.setAttribute('playsinline', true); // required to tell iOS safari we don't want fullscreen
          video.play();
          requestAnimationFrame(tick);

          this.stop = () => stream.getTracks().forEach(function (track) {
            track.stop();
          });
        });
      },
    });

    app.mount('#app');

  })().catch(console.error);
</script>

<style>
  .font-awesome {
    font-family: Courier;
  }

  .nav-link.active, .disabled, :disabled {
    cursor: default;
  }

  canvas, .qrcode {
    max-width: 100%;
  }

  canvas {
    border-radius: 10px;
    overflow: hidden;
  }
</style>

</body>
</html>
